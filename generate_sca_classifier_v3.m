% =================================================================================================
% File: generate_sca_classifier_v3.m
% Version: v3 (Refactored Layout)
% Purpose:
%   Based on *_info.mat metadata generated by predict_shhs1_all.m (no longer reads raw EDF signals):
%     1) Build a variable-window recovery dynamics feature system for PVC → sinus recovery
%     2) Train an imbalance-friendly binary classifier (Alive=1 / Dead=0)
%     3) Output feature table, train/test sets, model, evaluation results, and publication-grade plots
%
% Feature Focus:
%   - Post-PVC RR / T / approximate QTc recovery half-life, time constant
%   - Overshoot, oscillation index, phase instability (stalls), censoring ratio
%   - Complexity / nonlinearity: sample entropy, Lempel-Ziv complexity, segmented slopes, Poincaré ratio
%   - PVC coupling, heart rate peak acceleration, QTc deviation proportion
%
% Required Inputs (from *_info.mat):
%   predPVCIndices, patientVital, fs, recordNumSamples, rGlobalAll, isPVCBeat,
%   qrs_dur_vec, r_amp_vec, sqi_vec, t_amp_vec, tGlobalIndices
%
% Outputs:
%   results/post_ectopic_features_v3.mat        Record-level feature table (with NaN)
%   results/SCA_trainingFeatureTable_v3.mat     Training set (missing filled + normalized)
%   results/SCA_testingFeatureTable_v3.mat      Test set
%   results/sca_classifier_v3.mat               Trained model package
%   results/feature_effectiveness_*_v3.csv      Univariate discriminative power
%   results/roc / pr / calibration / decision_curve PNG images
%   results/permutation_importance_test_v3.csv  Permutation importance
%   results/ablation_demographic_physio_combined_v3.csv  Ablation experiments
%
% Main Pipeline:
%   1) Parameter config & path preparation
%   2) Load covariates (optional) + blacklist (optional)
%   3) Enumerate *_info.mat and extract PVC-level features per record → aggregate to record-level
%   4) Stratified train/test split (by patient ID) + missing imputation + MinMax normalization
%   5) Univariate evaluation
%   6) Model training (optionally auto hyperparam selection) + threshold / probability calibration
%   7) Evaluation & visualization output
%   8) Ablation / importance / save model package
%
% Constraints & Extensions:
%   - For more precise morphology (QT, ST, P wave, etc.) later, add fields during *_info.mat generation
%   - Removed unused legacy functions (local_build_confmat_text / local_build_empty_record etc.)
%
% Changelog:
%   2025-09-04: v3 initial
%   2025-10-08: Refactor reorder: centralized config, unified subfunctions at end, streamlined comments
% =================================================================================================

clc; clear; close all;

%% ================================================================================================
%  Global Configuration (centralized for tuning & version tracking)
% ================================================================================================

% Execution control
processFirstN          = 0;        % Process first N records (<=0 = all)
splitRatioTest         = 0.20;     % Test set proportion
randomSeed             = 42;       % RNG seed
enableBlacklist        = false;    % Whether blacklist is enabled
includeDemographics    = true;     % Whether to include demographic covariates
rng(randomSeed);

% Paths
rootDir   = pwd;
edfDir    = fullfile(rootDir, 'shhs','polysomnography','edfs','shhs1');
resultsDir= fullfile(rootDir, 'results');
if ~isfolder(edfDir), error('EDF (info MAT) directory not found: %s', edfDir); end
if ~isfolder(resultsDir), mkdir(resultsDir); end
addpath(genpath(rootDir));

% Input covariate CSV (optional)
covarCsv = fullfile(rootDir, 'shhs','datasets','shhs-cvd-summary-dataset-0.21.0.csv');

% Recovery / baseline / determination parameters
params = struct();
params.baselineSec        = 50;    % Look-back baseline window before PVC (sec)
params.baselineMinBeats   = 10;    % Minimum valid sinus beats for baseline
params.maxObsSec          = 50;    % Max observation window after PVC (sec)
params.consecStableBeats  = 10;    % Consecutive stable beats required to declare recovery
params.rrTolFrac          = 0.08;  % RR deviation tolerance: |RR-μRR| <= max(frac*μRR, sigma*σRR)
params.rrTolSigma         = 1.5;
params.hrt_ts_low_thr     = 0.0;   % HRT TS low threshold (smaller is worse)
params.minRR              = 0.30;  % Plausible RR lower bound (sec)
params.maxRR              = 2.50;  % Plausible RR upper bound (sec)
params.minPVCPerRecord    = 10;    % Minimum number of PVCs per record
params.minSQIRatio        = 0.60;  % Threshold for ratio of good SQI sinus beats

% Model parameters / imbalance & threshold
modelOptions = struct();
modelOptions.Method                = 'AdaBoostM1';   % 'AdaBoostM1' | 'GentleBoost' | 'LogitBoost' | 'RUSBoost' | 'auto'
modelOptions.NumLearningCycles     = 200;
modelOptions.LearnRate             = 0.02;
modelOptions.MaxNumSplits          = 20;
modelOptions.MinLeafSize           = 32;
modelOptions.NumVariablesToSample  = 'sqrt';
modelOptions.enableCostMatrix      = true;
modelOptions.costFP                = 2;
modelOptions.costFN                = 6;
modelOptions.enableThresholdMoving = true;
modelOptions.pvcThreshold          = 0.21;           % Initial threshold (updated after CV)
modelOptions.cvKFold               = 10;
modelOptions.thrCandidates         = 0.02:0.01:0.98;
modelOptions.calibrationMethod     = 'auto';         % 'platt'|'isotonic'|'auto'
modelOptions.candidateMethods      = {'LogitBoost','GentleBoost','AdaBoostM1','RUSBoost'};
modelOptions.searchGrid = struct();
modelOptions.searchGrid.NumLearningCycles    = [200, 300];
modelOptions.searchGrid.LearnRate            = [0.02, 0.03, 0.05];
modelOptions.searchGrid.MaxNumSplits         = [20, 40];
modelOptions.searchGrid.MinLeafSize          = [20, 32];
modelOptions.searchGrid.NumVariablesToSample = {'sqrt'};
modelOptions.autoSelectVerbose               = true;
modelOptions.disableAutoInAblation           = true;

% Output filenames
featOutFile  = fullfile(resultsDir, 'post_ectopic_features_v3.mat');
trainTblFile = fullfile(resultsDir, 'SCA_trainingFeatureTable_v3.mat');
testTblFile  = fullfile(resultsDir, 'SCA_testingFeatureTable_v3.mat');
modelOutFile = fullfile(resultsDir, 'sca_classifier_v3.mat');

fprintf('=== SCA Risk (v3) Variable-Recovery Feature Pipeline (Refactored) ===\n');
fprintf('Info MAT directory: %s\n', edfDir);

%% ================================================================================================
%  Load Covariates (optional)
% ================================================================================================
covarMap = containers.Map('KeyType','char','ValueType','any');
if exist(covarCsv,'file')
    try
        Tcov = readtable(covarCsv);
        if any(strcmpi(Tcov.Properties.VariableNames,'nsrrid'))
            idStr = string(Tcov.nsrrid);
        else
            idStr = string(Tcov{:,1});
        end
        has_gender = any(strcmpi(Tcov.Properties.VariableNames,'gender'));
        has_race   = any(strcmpi(Tcov.Properties.VariableNames,'race'));
        has_age    = any(strcmpi(Tcov.Properties.VariableNames,'age_s1'));
        for ii = 1:height(Tcov)
            key = char(strtrim(idStr(ii)));
            val = struct();
            if has_gender, val.gender = double(Tcov.gender(ii)); else, val.gender = NaN; end
            if has_race,   val.race   = double(Tcov.race(ii));   else, val.race   = NaN; end
            if has_age,    val.age_s1 = double(Tcov.age_s1(ii)); else, val.age_s1 = NaN; end
            covarMap(key) = val;
        end
        fprintf('Loaded covariates (%d rows)\n', height(Tcov));
    catch ME
        fprintf('Covariate load failed: %s\n', ME.message);
    end
else
    fprintf('Covariate CSV not found, skip.\n');
end

%% ================================================================================================
%  Blacklist (optional)
% ================================================================================================
blackListIds = string([]);
blackListNames = string([]);
if enableBlacklist
    blacklistFile = fullfile(resultsDir, 'badsignallist.csv');
    if exist(blacklistFile,'file')
        try
            C = readcell(blacklistFile);
            vals = string(C(:));
            vals = strtrim(replace(replace(vals, '"',''),'''',''));
            vals = vals(vals~="");
            isDigits = ~cellfun('isempty', regexp(cellstr(vals), '^\d+$', 'once'));
            ids = vals(isDigits);
            names = vals(~isDigits);
            recIdFromNames = strings(0,1);
            for ii = 1:numel(names)
                tok = regexp(names(ii),'(\d+)','tokens','once');
                if ~isempty(tok)
                    recIdFromNames(end+1,1) = string(tok{1});
                end
            end
            blackListIds   = unique([ids; recIdFromNames]);
            blackListNames = unique("shhs1-" + blackListIds);
            fprintf('Blacklist loaded: %d entries\n', numel(blackListIds));
        catch ME
            fprintf('Blacklist load failed: %s\n', ME.message);
        end
    else
        fprintf('Blacklist file missing, skip.\n');
    end
else
    fprintf('Blacklist disabled.\n');
end

%% ================================================================================================
%  Enumerate *_info.mat
% ================================================================================================
infoFilesA = dir(fullfile(edfDir, 'shhs1-*_*info.mat'));
infoFilesB = dir(fullfile(edfDir, 'shhs1-*_info.mat'));
allPaths = unique([ ...
    arrayfun(@(d) fullfile(d.folder,d.name), infoFilesA,'UniformOutput',false), ...
    arrayfun(@(d) fullfile(d.folder,d.name), infoFilesB,'UniformOutput',false) ]);
if isempty(allPaths), error('No *_info.mat found under %s', edfDir); end
allPaths = sort(allPaths);
if processFirstN > 0
    allPaths = allPaths(1:min(processFirstN,numel(allPaths)));
end
fprintf('Planned records: %d\n', numel(allPaths));

%% ================================================================================================
%  Iterate records → PVC-level features → aggregate to record-level
% ================================================================================================
allRowTables = cell(0,1);
numSkippedQuality = 0;

requiredFields = {'predPVCIndices','patientVital','fs','recordNumSamples','rGlobalAll', ...
    'isPVCBeat','qrs_dur_vec','r_amp_vec','sqi_vec','t_amp_vec','tGlobalIndices'};

for iFile = 1:numel(allPaths)
    infoPath = allPaths{iFile};
    [~, baseName] = fileparts(infoPath);
    recBase = erase(baseName, '_info');
    recIdTok = regexp(recBase, 'shhs1-(\d+)$','tokens','once');
    recIdStr = "";
    if ~isempty(recIdTok), recIdStr = string(recIdTok{1}); end

    if enableBlacklist && (any(blackListNames==string(recBase)) || (strlength(recIdStr)>0 && any(blackListIds==recIdStr)))
        fprintf('  [%d/%d] Skip blacklist: %s\n', iFile, numel(allPaths), recBase);
        continue;
    end

    fprintf('\n--- [%d/%d] Load %s\n', iFile, numel(allPaths), [baseName '.mat']);
    try
        S = load(infoPath);
    catch ME
        fprintf('  Load failed: %s\n', ME.message);
        continue;
    end

    miss = requiredFields(~cellfun(@(f) isfield(S,f) && ~isempty(S.(f)), requiredFields));
    if ~isempty(miss)
        fprintf('  Skip missing fields: %s\n', strjoin(miss, ', '));
        continue;
    end

    patientVital = double(S.patientVital);
    if ~isfinite(patientVital)
        fprintf('  Skip: patientVital invalid.\n');
        continue;
    end

    fs  = double(S.fs);
    N   = double(S.recordNumSamples);
    rGlobalAll = double(S.rGlobalAll(:));
    isPVCBeat  = logical(S.isPVCBeat(:));
    qrs_dur_vec= double(S.qrs_dur_vec(:));
    r_amp_vec  = double(S.r_amp_vec(:)); %#ok<NASGU>
    sqi_vec    = logical(S.sqi_vec(:));
    t_amp_vec  = double(S.t_amp_vec(:));
    tGlobalIdx = double(S.tGlobalIndices(:));
    if any([numel(isPVCBeat),numel(qrs_dur_vec),numel(t_amp_vec),numel(tGlobalIdx),numel(sqi_vec)] ~= numel(rGlobalAll))
        fprintf('  Skip: vector length mismatch.\n');
        continue;
    end

    pvcRidx = sort(double(S.predPVCIndices(:)));
    pvcRidx = pvcRidx(isfinite(pvcRidx));
    numPVC  = numel(pvcRidx);
    fprintf('  Beats=%d fs=%.1f PVC=%d\n', numel(rGlobalAll), fs, numPVC);
    if numPVC == 0
        fprintf('  Skip quality: PVC=0\n');
        numSkippedQuality = numSkippedQuality + 1;
        continue;
    end

    numBeats = numel(rGlobalAll);
    rr_between = nan(numBeats,1);
    if numBeats>=2
        rr_between(2:end) = diff(rGlobalAll)/fs;
    end

    idxPVC_all_sorted = round(interp1(rGlobalAll, 1:numel(rGlobalAll), pvcRidx, 'nearest','extrap'));
    idxPVC_all_sorted = max(1, min(numBeats, idxPVC_all_sorted));

    % Record-level SQI window quality
    try
        j_all = (2:numBeats).';
        mask_all = ~isPVCBeat(j_all) & ~isPVCBeat(j_all-1) & isfinite(rr_between(j_all));
        sqi_ratio = mean(double(sqi_vec(j_all(mask_all))), 'omitnan');
    catch
        sqi_ratio = NaN;
    end
    if numPVC < params.minPVCPerRecord || ~(isfinite(sqi_ratio) && sqi_ratio>=params.minSQIRatio)
        fprintf('  Skip quality: PVC=%d SQIratio=%.2f (minPVC=%d minSQI=%.2f)\n', ...
            numPVC, sqi_ratio, params.minPVCPerRecord, params.minSQIRatio);
        numSkippedQuality = numSkippedQuality + 1;
        continue;
    end

    % --- PVC-level feature containers ---
    halflife_rr       = nan(numPVC,1);
    halflife_rr_30    = nan(numPVC,1);
    halflife_rr_10    = nan(numPVC,1);
    tau_rr            = nan(numPVC,1);
    auc_rr            = nan(numPVC,1);
    overshoot_rr      = nan(numPVC,1);
    oscill_rr         = nan(numPVC,1);
    stalls_rr         = nan(numPVC,1);
    notRecovered_rr   = false(numPVC,1);

    halflife_tamp     = nan(numPVC,1);
    auc_tamp          = nan(numPVC,1);
    halflife_qtc      = nan(numPVC,1);
    auc_qtc           = nan(numPVC,1);

    hrt_to            = nan(numPVC,1);
    hrt_ts            = nan(numPVC,1);
    coupling_ratio    = nan(numPVC,1);
    hr_peak_accel_bpm = nan(numPVC,1);
    late_var_rr       = nan(numPVC,1);
    pvc_to_next_nonPVC_sec = nan(numPVC,1);

    % High discriminative / complexity
    early_mean_dev_rr = nan(numPVC,1);
    late_mean_dev_rr  = nan(numPVC,1);
    slope_rr_dev_0_5s = nan(numPVC,1);
    slope_rr_dev_5_15s= nan(numPVC,1);
    sampen_rr         = nan(numPVC,1);
    lzc_rr            = nan(numPVC,1);
    poincare_ratio_pp = nan(numPVC,1);
    dev_rr_q95        = nan(numPVC,1);
    tamp_rr_corr      = nan(numPVC,1);
    qtc_over_frac     = nan(numPVC,1);
    qtc_over_mag      = nan(numPVC,1);

    % PVC loop
    for kk = 1:numPVC
        pvcSample = pvcRidx(kk);
        idxPVC    = idxPVC_all_sorted(kk);

        nextPVCsample = inf;
        if kk < numPVC
            nextPVCsample = pvcRidx(kk+1);
        end
        obsEnd = min([double(N), double(pvcSample)+round(params.maxObsSec*fs), double(nextPVCsample)-1]);
        if ~(isfinite(obsEnd) && obsEnd > pvcSample)
            notRecovered_rr(kk) = true;
            continue;
        end

        [muRR, sigRR, baseRR_vec, muTamp, muQTc] = local_baseline_stats(idxPVC, pvcSample, ...
            rGlobalAll, rr_between, isPVCBeat, sqi_vec, t_amp_vec, tGlobalIdx, ...
            qrs_dur_vec, fs, params); %#ok<ASGLU>
        if ~isfinite(muRR) || muRR<=0
            notRecovered_rr(kk) = true;
            continue;
        end

        % Pre/post RR
        rr_pre=nan; rr_post1=nan; rr_post2=nan;
        if idxPVC>=2,      rr_pre   = rr_between(idxPVC); end
        if idxPVC+1<=numBeats, rr_post1 = rr_between(idxPVC+1); end
        if idxPVC+2<=numBeats, rr_post2 = rr_between(idxPVC+2); end

        if isfinite(rr_pre) && isfinite(rr_post1) && rr_pre>0
            hrt_to(kk) = (rr_post1 - rr_pre) / rr_pre;
        end
        hrt_ts(kk) = local_approx_ts(idxPVC, pvcSample, obsEnd, rGlobalAll, rr_between, isPVCBeat, sqi_vec);

        if isfinite(rr_pre), coupling_ratio(kk) = rr_pre / muRR; end
        try
            hr0 = 60/max(muRR,eps);
            hr1 = 60/max(rr_post1,eps);
            hr2 = 60/max(rr_post2,eps);
            hr_peak_accel_bpm(kk) = max([hr1-hr0, hr2-hr0]);
        catch
            hr_peak_accel_bpm(kk)=NaN;
        end

        % Post-PVC non-PVC + good SQI sequence
        j_after = (idxPVC+1):numBeats;
        keep = false(size(j_after));
        for jj = 1:numel(j_after)
            j = j_after(jj);
            if rGlobalAll(j) > obsEnd, break; end
            if j>=2 && ~isPVCBeat(j) && ~isPVCBeat(j-1) && sqi_vec(j) && sqi_vec(j-1) && ...
                    isfinite(rr_between(j)) && rr_between(j)>=params.minRR && rr_between(j)<=params.maxRR
                keep(jj)=true;
            end
        end
        j_after = j_after(keep);
        if isempty(j_after)
            notRecovered_rr(kk)=true;
            continue;
        end
        t_after = (double(rGlobalAll(j_after)) - double(pvcSample))/fs;
        rr_seq  = rr_between(j_after);
        dev_rr  = abs(rr_seq - muRR)./max(muRR,eps);

        % Half-lives
        halflife_rr(kk)    = local_halflife(dev_rr, t_after, 0.50, params.consecStableBeats);
        halflife_rr_30(kk) = local_halflife(dev_rr, t_after, 0.30, params.consecStableBeats);
        halflife_rr_10(kk) = local_halflife(dev_rr, t_after, 0.10, params.consecStableBeats);
        if ~isfinite(halflife_rr(kk)) && t_after(end) < params.maxObsSec
            notRecovered_rr(kk) = true;
        end

        tau_rr(kk)      = local_time_constant(dev_rr, t_after, 8);
        auc_rr(kk)      = local_auc(dev_rr, t_after, params.baselineSec);
        overshoot_rr(kk)= max(dev_rr)-dev_rr(1);
        oscill_rr(kk)   = local_oscillation_index(dev_rr);
        stalls_rr(kk)   = local_recovery_stalls(dev_rr, 0.20, params.consecStableBeats);

        late_mask = t_after >= 5;
        if any(late_mask)
            late_var_rr(kk) = var(dev_rr(late_mask), 'omitnan');
        end

        % T amplitude recovery
        tamp_seq = t_amp_vec(j_after);
        if isfinite(muTamp) && muTamp>0
            dev_tamp = abs(tamp_seq - muTamp)./muTamp;
            halflife_tamp(kk)= local_halflife(dev_tamp, t_after, 0.50, params.consecStableBeats);
            auc_tamp(kk)     = local_auc(dev_tamp, t_after, params.baselineSec);
        else
            dev_tamp = nan(size(dev_rr));
        end

        % QTc recovery
        qtc_seq = local_qtc_series(j_after, rGlobalAll, tGlobalIdx, qrs_dur_vec, rr_between, fs);
        if ~isempty(qtc_seq) && any(isfinite(qtc_seq)) && isfinite(muQTc) && muQTc>0
            dev_qtc = abs(qtc_seq - muQTc)./muQTc;
            halflife_qtc(kk) = local_halflife(dev_qtc, t_after(1:numel(qtc_seq)), 0.50, params.consecStableBeats);
            auc_qtc(kk)      = local_auc(dev_qtc, t_after(1:numel(qtc_seq)), params.baselineSec);
            qtc_over_frac(kk)= mean(dev_qtc > 0.10, 'omitnan');
            qtc_over_mag(kk) = max(max(dev_qtc)-0.10, 0);
        end

        % Complexity / slopes / entropy / LZ
        early_mask = (t_after>=0)&(t_after<=5);
        late_mask2= (t_after>5)&(t_after<=15);
        if any(early_mask)
            early_mean_dev_rr(kk) = mean(dev_rr(early_mask),'omitnan');
            slope_rr_dev_0_5s(kk) = local_linear_slope(t_after(early_mask), dev_rr(early_mask));
        end
        if any(late_mask2)
            late_mean_dev_rr(kk)  = mean(dev_rr(late_mask2),'omitnan');
            slope_rr_dev_5_15s(kk)= local_linear_slope(t_after(late_mask2), dev_rr(late_mask2));
        end
        try
            sampen_rr(kk) = local_sampen(dev_rr, 2, 0.2*std(dev_rr,'omitnan'));
        catch
            sampen_rr(kk)=NaN;
        end
        try
            d1 = diff(dev_rr(:));
            lzc_rr(kk) = local_lzc_binary(double(d1>=0));
        catch
            lzc_rr(kk)=NaN;
        end
        try
            [SD1_pre, SD2_pre] = local_poincare_sd(baseRR_vec);
            post_mask10 = t_after <= 10;
            if any(post_mask10)
                [SD1_post, SD2_post] = local_poincare_sd(rr_seq(post_mask10));
                r_pre  = SD1_pre/max(SD2_pre,eps);
                r_post = SD1_post/max(SD2_post,eps);
                if isfinite(r_pre) && r_pre>0 && isfinite(r_post)
                    poincare_ratio_pp(kk) = r_post / r_pre;
                end
            end
        catch
            poincare_ratio_pp(kk)=NaN;
        end
        try
            dev_rr_q95(kk) = quantile(dev_rr,0.95);
        catch
            dev_rr_q95(kk)=NaN;
        end
        try
            if numel(dev_tamp)==numel(dev_rr)
                tamp_rr_corr(kk) = corr(dev_rr(:), dev_tamp(:), 'type','Spearman','rows','pairwise');
            end
        catch
            tamp_rr_corr(kk)=NaN;
        end

        % PVC → next non-PVC interval
        try
            j_search = (idxPVC+1):numBeats;
            next_nonPVC_j = NaN;
            for jj = j_search
                if ~isPVCBeat(jj)
                    next_nonPVC_j = jj; break;
                end
            end
            if isfinite(next_nonPVC_j)
                pvc_to_next_nonPVC_sec(kk) = (double(rGlobalAll(next_nonPVC_j)) - double(pvcSample))/fs;
                if ~(isfinite(pvc_to_next_nonPVC_sec(kk)) && pvc_to_next_nonPVC_sec(kk)>=0)
                    pvc_to_next_nonPVC_sec(kk)=NaN;
                end
            end
        catch
            pvc_to_next_nonPVC_sec(kk)=NaN;
        end
    end % end PVC loop

    % --- Record-level aggregation ---
    recDurationHr = (N/fs)/3600;
    pvcPerHour = numPVC / max(recDurationHr,eps);
    recovery_failure_ratio = mean(double(notRecovered_rr));

    agg_mean = @(v) mean(v(isfinite(v)),'omitnan');
    agg_med  = @(v) median(v(isfinite(v)));
    agg_max  = @(v) local_safe_max(v);
    agg_min  = @(v) local_safe_min(v);

    R = struct();
    R.record                     = string(recBase);
    R.patientVital               = patientVital;
    R.PVCs_per_hour              = pvcPerHour;
    R.PVC_count                  = numPVC;
    R.recovery_failure_ratio     = recovery_failure_ratio;
    R.halflife_rr_median         = agg_med(halflife_rr);
    R.halflife_rr30_median       = agg_med(halflife_rr_30);
    R.halflife_rr10_median       = agg_med(halflife_rr_10);
    R.tau_rr_median              = agg_med(tau_rr);
    R.oscill_rr_median           = agg_med(oscill_rr);
    R.HRT_TO_abnormal_frac       = mean(double(isfinite(hrt_to) & (hrt_to>=0)),'omitnan');
    R.HRT_TS_low_frac            = mean(double(isfinite(hrt_ts) & (hrt_ts<=params.hrt_ts_low_thr)),'omitnan');
    R.halflife_tamp_median       = agg_med(halflife_tamp);
    R.halflife_qtc_median        = agg_med(halflife_qtc);
    R.auc_qtc_mean               = agg_mean(auc_qtc);

    % Baseline RMSSD (aggregated over per-PVC baseline sets)
    try
        rmssd_base = local_rmssd_from_base_perPVC(idxPVC_all_sorted, pvcRidx, rGlobalAll, ...
            rr_between, isPVCBeat, sqi_vec, fs, params);
        R.RR_Pre_RMSSD_mean = mean(rmssd_base(isfinite(rmssd_base)),'omitnan');
    catch
        R.RR_Pre_RMSSD_mean = NaN;
    end

    R.coupling_ratio_mean        = agg_mean(coupling_ratio);
    R.hr_peak_accel_bpm_mean     = agg_mean(hr_peak_accel_bpm);

    medEarly = agg_med(early_mean_dev_rr);
    medLate  = agg_med(late_mean_dev_rr);
    R.rr_dev_late_minus_early    = medLate - medEarly;
    R.rr_dev_slope_0_5s_med      = agg_med(slope_rr_dev_0_5s);
    R.tamp_rr_corr_med           = agg_med(tamp_rr_corr);
    R.qtc_overshoot_frac_mean    = agg_mean(qtc_over_frac);

    try
        hl = halflife_rr(isfinite(halflife_rr) & halflife_rr>0);
        if ~isempty(hl)
            R.recovery_rate_hmean = mean(1./hl);
        else
            R.recovery_rate_hmean = NaN;
        end
    catch
        R.recovery_rate_hmean = NaN;
    end

    R.PVC_to_next_nonPVC_sec_mean = agg_mean(pvc_to_next_nonPVC_sec);
    R.PVC_to_next_nonPVC_sec_max  = agg_max(pvc_to_next_nonPVC_sec);
    R.PVC_to_next_nonPVC_sec_min  = agg_min(pvc_to_next_nonPVC_sec);

    % Covariates
    try
        recIdTok = regexp(string(recBase), 'shhs1-(\d+)$', 'tokens','once');
        nsrrid = "";
        if ~isempty(recIdTok), nsrrid = string(recIdTok{1}); end
        R.nsrrid = nsrrid;
        val = [];
        if strlength(nsrrid)>0 && isKey(covarMap, char(nsrrid))
            val = covarMap(char(nsrrid));
        end
        if ~isempty(val)
            R.age_s1 = val.age_s1;
        else
            R.age_s1 = NaN;
        end
    catch
        R.nsrrid = ""; R.age_s1 = NaN;
    end

    allRowTables{end+1,1} = struct2table(R,'AsArray',true);
end

if isempty(allRowTables)
    error('No usable records → featureTable empty.');
end
featureTable = vertcat(allRowTables{:});
fprintf('\nCollected %d records. Skipped (quality)=%d\n', height(featureTable), numSkippedQuality);

% Save raw aggregation (with NaN)
try
    save(featOutFile, 'featureTable');
    fprintf('✓ Saved feature table: %s\n', featOutFile);
catch ME
    fprintf('Save feature table failed: %s\n', ME.message);
end

%% ================================================================================================
%  Missing Imputation + Stratified Split (by patient ID) + Normalization
% ================================================================================================
names = featureTable.Properties.VariableNames;
isNum = cellfun(@(c) isnumeric(featureTable.(c)) && isvector(featureTable.(c)), names);

if includeDemographics
    excludePredictors = {'patientVital'};
else
    excludePredictors = {'patientVital','age_s1','gender','race'};
end
predictorMask  = isNum & ~ismember(names, excludePredictors);
predictorNames = names(predictorMask);
responseName   = 'patientVital';

fprintf('\nPredictor count: %d\n', numel(predictorNames));

% Median imputation
for i = 1:numel(predictorNames)
    col = featureTable.(predictorNames{i});
    if ~isnumeric(col), continue; end
    nanMask = isnan(col);
    if any(nanMask)
        medv = median(col(~nanMask));
        if isempty(medv) || isnan(medv), medv = 0; end
        col(nanMask) = medv;
        featureTable.(predictorNames{i}) = col;
    end
end

% Build group (patient ID)
recNames  = string(featureTable.record);
patientId = strings(height(featureTable),1);
for ii = 1:height(featureTable)
    nm = recNames(ii);
    tok = regexp(nm, 'shhs1-(\d+)$','tokens','once');
    if ~isempty(tok)
        patientId(ii) = string(tok{1});
    else
        tok2 = regexp(nm,'(\d+)','tokens','once');
        if ~isempty(tok2)
            patientId(ii) = string(tok2{1});
        else
            patientId(ii) = nm;
        end
    end
end
y = featureTable.(responseName);
if iscell(y), y = cell2mat(y); end
if islogical(y), y = double(y); end

[trainMask, testMask] = local_group_stratified_split(patientId, y, splitRatioTest, randomSeed);
trainingFeatureTable = featureTable(trainMask,:);
testingFeatureTable  = featureTable(testMask,:);
fprintf('Train=%d  Test=%d\n', height(trainingFeatureTable), height(testingFeatureTable));

% Min-Max normalization (based on training set)
try
    scaler = struct();
    scaler.method = 'minmax';
    scaler.featureNames = predictorNames;
    scaler.min = nan(numel(predictorNames),1);
    scaler.max = nan(numel(predictorNames),1);
    for i = 1:numel(predictorNames)
        fn = predictorNames{i};
        tr = double(trainingFeatureTable.(fn));
        mn = min(tr,[],'omitnan');
        mx = max(tr,[],'omitnan');
        if ~isfinite(mn), mn = 0; end
        if ~isfinite(mx), mx = mn + 1; end
        denom = mx - mn;
        if ~(isfinite(denom) && denom>0)
            trScaled = zeros(size(tr));
            teScaled = zeros(size(testingFeatureTable.(fn)));
        else
            trScaled = (tr - mn)./denom;
            te = double(testingFeatureTable.(fn));
            teScaled = (te - mn)./denom;
            trScaled = min(max(trScaled,0),1);
            teScaled = min(max(teScaled,0),1);
        end
        trainingFeatureTable.(fn) = trScaled;
        testingFeatureTable.(fn)  = teScaled;
        scaler.min(i)=mn; scaler.max(i)=mx;
    end
    fprintf('Applied Min-Max normalization.\n');
catch ME
    fprintf('Normalization failed: %s\n', ME.message);
end

% Save train / test tables
try, save(trainTblFile,'trainingFeatureTable'); fprintf('✓ Saved training table\n'); catch ME, fprintf('Train table save failed: %s\n', ME.message); end
try, save(testTblFile,'testingFeatureTable');   fprintf('✓ Saved testing table\n');  catch ME, fprintf('Test table save failed: %s\n', ME.message); end

%% ================================================================================================
%  Univariate Feature Effectiveness (AUC / d / Mutual Info / Rank test)
% ================================================================================================
fprintf('\n=== Univariate Feature Effectiveness (Train/Test, Dead Positive) ===\n');
featStatsTrain = local_feature_effectiveness(trainingFeatureTable, predictorNames, responseName, 'Train');
featStatsTest  = local_feature_effectiveness(testingFeatureTable,  predictorNames, responseName, 'Test');

try
    writetable(featStatsTrain, fullfile(resultsDir,'feature_effectiveness_train_v3.csv'));
    writetable(featStatsTest,  fullfile(resultsDir,'feature_effectiveness_test_v3.csv'));
catch
end

%% ================================================================================================
%  Model Training + Threshold Tuning + Evaluation
% ================================================================================================
[trainedClassifier, valAcc] = local_train_model(trainingFeatureTable, predictorNames, responseName, modelOptions);
fprintf('Cross-validated accuracy (internal) = %.2f%%\n', 100*valAcc);

if modelOptions.enableThresholdMoving
    trainedClassifier = local_threshold_tuning(trainedClassifier, trainingFeatureTable, predictorNames, responseName, modelOptions);
end

fprintf('\n=== Evaluation (English Confusion Matrices) ===\n');
try
    optsEval = trainedClassifier.Options;
catch
    optsEval = modelOptions;
end
fprintf('Method=%s | NLC=%d | LR=%.3f | MaxSplits=%d | MinLeaf=%d | NumVars=%s\n', ...
    char(optsEval.Method), optsEval.NumLearningCycles, optsEval.LearnRate, ...
    optsEval.MaxNumSplits, optsEval.MinLeafSize, mat2str(optsEval.NumVariablesToSample));

[train_predVital, ~] = local_predict_with_threshold(trainedClassifier, trainingFeatureTable, predictorNames);
train_yTrue = trainingFeatureTable.(responseName); if iscell(train_yTrue), train_yTrue = cell2mat(train_yTrue); end
local_print_confusion('Train', train_yTrue, train_predVital);

[predVital, scoresDead] = local_predict_with_threshold(trainedClassifier, testingFeatureTable, predictorNames);
yTrue = testingFeatureTable.(responseName); if iscell(yTrue), yTrue = cell2mat(yTrue); end
local_print_confusion('Test', yTrue, predVital);

% AUC / AUPRC / Brier (Dead positive)
try
    yTrueDead = 1 - yTrue;
    [~,~,~,aucTest] = perfcurve(yTrueDead, scoresDead, 1);
catch
    aucTest = NaN;
end
try
    scoresProb_eval = scoresDead;
    if isfield(trainedClassifier.Options,'calibrationBeta')
        scoresProb_eval = glmval(trainedClassifier.Options.calibrationBeta, scoresDead, 'logit');
    end
    [~,~,~,aucPR] = perfcurve(yTrueDead, scoresProb_eval, 1, 'XCrit','reca','YCrit','prec');
catch
    aucPR = NaN;
end
try
    brier = mean((scoresProb_eval - yTrueDead).^2);
catch
    brier = NaN;
end
fprintf('Test AUC=%.3f | AUPRC=%.3f | Brier=%.4f\n', aucTest, aucPR, brier);

% Evaluation plots
try
    local_generate_publication_plots(trainedClassifier, trainingFeatureTable, testingFeatureTable, predictorNames, responseName, resultsDir);
catch ME
    fprintf('Plot generation failed: %s\n', ME.message);
end

%% ================================================================================================
%  Ablation Experiments (Demographic / Physio / Combined)
% ================================================================================================
try
    demoVars = intersect(predictorNames, {'age_s1','gender','race'});
    physVars = setdiff(predictorNames, demoVars);
    sets     = {demoVars, physVars, predictorNames};
    setNames = {'demographic_only','physio_only','combined'};
    abRows = strings(0,1); AUCs=[]; AUPRCs=[]; Briers=[]; F1ds=[];
    for si = 1:numel(sets)
        varsS = sets{si};
        if isempty(varsS)
            abRows(end+1,1)=string(setNames{si}); AUCs(end+1,1)=NaN; AUPRCs(end+1,1)=NaN; Briers(end+1,1)=NaN; F1ds(end+1,1)=NaN;
            continue;
        end
        abOptions = modelOptions;
        if isfield(modelOptions,'disableAutoInAblation') && modelOptions.disableAutoInAblation
            if isfield(trainedClassifier,'Options')
                abOptions = trainedClassifier.Options;
            end
            if isfield(abOptions,'selectedMethod'), abOptions.Method = abOptions.selectedMethod; end
            if strcmpi(char(abOptions.Method),'auto'), abOptions.Method='GentleBoost'; end
            abOptions.autoSelectVerbose = false;
        end
        [mdlS, ~] = local_train_model(trainingFeatureTable, varsS, responseName, abOptions);
        mdlS = local_threshold_tuning(mdlS, trainingFeatureTable, varsS, responseName, abOptions);
        [yhatS, scoreS] = local_predict_with_threshold(mdlS, testingFeatureTable, varsS);
        yTrueS = testingFeatureTable.(responseName); if iscell(yTrueS), yTrueS = cell2mat(yTrueS); end
        yDeadS = 1 - yTrueS;
        try
            [~,~,~,aucS] = perfcurve(yDeadS, scoreS, 1);
        catch
            aucS = NaN;
        end
        try
            probS = scoreS;
            if isfield(mdlS.Options,'calibrationBeta')
                probS = glmval(mdlS.Options.calibrationBeta, scoreS, 'logit');
            end
            [~,~,~,auprcS] = perfcurve(yDeadS, probS, 1, 'XCrit','reca','YCrit','prec');
            brierS = mean((probS - yDeadS).^2);
        catch
            auprcS = NaN; brierS = NaN;
        end
        yHatDeadS = 1 - yhatS;
        TP = sum((yDeadS==1)&(yHatDeadS==1));
        FP = sum((yDeadS==0)&(yHatDeadS==1));
        FN = sum((yDeadS==1)&(yHatDeadS==0));
        prec = TP/max(TP+FP,eps); rec = TP/max(TP+FN,eps);
        F1d = (prec+rec>0) * (2*prec*rec/(prec+rec));
        abRows(end+1,1)=string(setNames{si});
        AUCs(end+1,1)=aucS; AUPRCs(end+1,1)=auprcS; Briers(end+1,1)=brierS; F1ds(end+1,1)=F1d;
    end
    abTable = table(abRows,AUCs,AUPRCs,Briers,F1ds,'VariableNames',{'Setting','AUC','AUPRC','Brier','F1_Dead'});
    disp(abTable);
    try, writetable(abTable, fullfile(resultsDir,'ablation_demographic_physio_combined_v3.csv')); catch, end
catch ME
    fprintf('Ablation failed: %s\n', ME.message);
end

%% ================================================================================================
%  Feature Importance
% ================================================================================================
modelImportance = struct();
try
    imp = predictorImportance(trainedClassifier.ClassificationEnsemble);
    modelImportance.gain = array2table(imp(:)','VariableNames', trainedClassifier.RequiredVariables);
catch
end
try
    thrUsed = trainedClassifier.Options.pvcThreshold;
catch
    thrUsed = 0.5;
end
try
    permImp = local_permutation_importance(trainedClassifier, testingFeatureTable, predictorNames, responseName, thrUsed, 20);
    try, writetable(permImp, fullfile(resultsDir,'permutation_importance_test_v3.csv')); catch, end
catch
    permImp = table();
end

%% ================================================================================================
%  Save Model Package
% ================================================================================================
trainedModelPackage = struct();
trainedModelPackage.trainedClassifier           = trainedClassifier;
trainedModelPackage.requiredVariables           = predictorNames;
trainedModelPackage.responseName                = responseName;
trainedModelPackage.options                     = modelOptions;
trainedModelPackage.validationAccuracy          = valAcc;
trainedModelPackage.testAUC                     = aucTest;
trainedModelPackage.testAUPRC                   = aucPR;
trainedModelPackage.testBrier                   = brier;
trainedModelPackage.featureEffectivenessTrain   = featStatsTrain;
trainedModelPackage.featureEffectivenessTest    = featStatsTest;
trainedModelPackage.modelImportance             = modelImportance;
trainedModelPackage.permutationImportanceTest   = permImp;
trainedModelPackage.savedAt                     = datetime("now","Format","yyyy-MM-dd HH:mm:ss");

try
    save(modelOutFile, 'trainedClassifier','predictorNames','responseName','modelOptions','trainedModelPackage');
    fprintf('✓ Saved model: %s\n', modelOutFile);
catch ME
    fprintf('Save model failed: %s\n', ME.message);
end

fprintf('\nAll done.\n');

%% =================================================================================================
%  Internal Functions (grouped by topic)
% =================================================================================================

% ---------------------------------------------------------------------------------
% Baseline & Recovery Core
% ---------------------------------------------------------------------------------
function [muRR, sigRR, baseRR_vec, muTamp, muQTc] = local_baseline_stats(~, pvcSample, rGlobalAll, rr_between, isPVCBeat, sqi_vec, t_amp_vec, tGlobalIdx, qrs_dur_vec, fs, params)
    baseA = max(1, double(pvcSample) - round(params.baselineSec*fs));
    baseB = max(1, double(pvcSample) - 1);
    j_in = find(rGlobalAll >= baseA & rGlobalAll <= baseB);
    j_in = j_in(:); j_in = j_in(j_in>=2);
    if ~isempty(j_in)
        mask_ok = ~isPVCBeat(j_in) & ~isPVCBeat(j_in-1) & sqi_vec(j_in) & sqi_vec(j_in-1) & isfinite(rr_between(j_in));
        baseRR_vec = rr_between(j_in(mask_ok));
    else
        baseRR_vec = [];
    end
    baseRR_vec = baseRR_vec(isfinite(baseRR_vec) & baseRR_vec>=params.minRR & baseRR_vec<=params.maxRR);

    if numel(baseRR_vec) < max(3, params.baselineMinBeats)
        j_all = (2:numel(rGlobalAll)).';
        mask_all = ~isPVCBeat(j_all) & ~isPVCBeat(j_all-1) & sqi_vec(j_all) & sqi_vec(j_all-1) & isfinite(rr_between(j_all));
        rr_all = rr_between(j_all(mask_all)); rr_all = rr_all(isfinite(rr_all));
        if isempty(rr_all)
            muRR = median(rr_between(isfinite(rr_between)));
            sigRR= std(rr_between(isfinite(rr_between)));
        else
            muRR = median(rr_all);
            sigRR= std(rr_all);
        end
    else
        muRR = mean(baseRR_vec);
        sigRR= std(baseRR_vec);
    end
    if ~isfinite(muRR) || muRR<=0, muRR = median(rr_between(isfinite(rr_between))); end
    if ~isfinite(sigRR), sigRR = 0; end

    muTamp = NaN; muQTc = NaN;
    try
        if ~isempty(j_in)
            j_ok = j_in(~isnan(t_amp_vec(j_in)) & isfinite(t_amp_vec(j_in)));
            t_base = t_amp_vec(j_ok);
            if ~isempty(t_base), muTamp = mean(abs(t_base)); end
        end
    catch, muTamp = NaN; end
    try
        j_ok = j_in;
        keep = false(size(j_ok));
        for mm = 1:numel(j_ok)
            j = j_ok(mm);
            if isfinite(tGlobalIdx(j)) && tGlobalIdx(j) > rGlobalAll(j) && isfinite(rr_between(j)) && rr_between(j)>0
                QT_approx = ((tGlobalIdx(j)-rGlobalAll(j))/fs) + 0.5*max(qrs_dur_vec(j),0);
                if isfinite(QT_approx) && QT_approx>=0.20 && QT_approx<=0.60
                    keep(mm)=true;
                end
            end
        end
        j_ok = j_ok(keep);
        if ~isempty(j_ok)
            qtc_vals = nan(numel(j_ok),1);
            for k = 1:numel(j_ok)
                j = j_ok(k);
                rrj = rr_between(j);
                QT_approx = ((tGlobalIdx(j)-rGlobalAll(j))/fs) + 0.5*max(qrs_dur_vec(j),0);
                qtc_vals(k)= QT_approx / (rrj^(1/3));
            end
            qtc_vals = qtc_vals(isfinite(qtc_vals) & qtc_vals>=0.30 & qtc_vals<=0.70);
            if ~isempty(qtc_vals), muQTc = mean(qtc_vals); end
        end
    catch, muQTc = NaN; end
end

function ts_val = local_approx_ts(idxPVC, pvcSample, obsEnd, rGlobalAll, rr_between, isPVCBeat, sqi_vec)
    numBeats = numel(rGlobalAll);
    j_after = (idxPVC+1):min(numBeats, idxPVC+20);
    j_after = j_after(:);
    mask_rr_ok = (rGlobalAll(j_after) <= obsEnd) & (rGlobalAll(j_after-1) >= pvcSample) & ...
        ~isPVCBeat(j_after) & ~isPVCBeat(j_after-1) & sqi_vec(j_after) & sqi_vec(j_after-1) & ...
        isfinite(rr_between(j_after));
    j_after = j_after(mask_rr_ok);
    ts_val = NaN;
    if numel(j_after) >= 7
        rr_seq = rr_between(j_after);
        maxSlope = -inf;
        for uu = 1:(numel(rr_seq)-4)
            slope = (rr_seq(uu+4) - rr_seq(uu)) / 4.0;
            if slope > maxSlope, maxSlope = slope; end
        end
        ts_val = maxSlope;
    end
end

function t50 = local_halflife(dev, t, thr, consecBeats)
    t50 = NaN;
    if isempty(dev)||isempty(t), return; end
    dev = dev(:); t = t(:);
    hit = dev <= thr;
    run = 0;
    for i = 1:numel(hit)
        if hit(i), run=run+1; else, run=0; end
        if run>=consecBeats
            t50 = t(i - consecBeats + 1); return;
        end
    end
end

function tau = local_time_constant(dev, t, K)
    tau = NaN;
    if isempty(dev)||isempty(t), return; end
    dev = dev(:); t = t(:);
    K = min([K, numel(dev), numel(t)]);
    y = log(max(dev(1:K), eps));
    x = t(1:K);
    if numel(unique(x))<2, return; end
    p = polyfit(x,y,1);
    a = p(1);
    if a < 0, tau = -1/a; end
end

function A = local_auc(dev, t, normTime)
    A=NaN;
    if numel(dev)<2 || numel(t)<2, A=0; return; end
    dev = dev(:); t = t(:);
    dt = diff(t)./max(normTime,1);
    for i=2:numel(dev)
        if isnan(dev(i)), dev(i)=dev(i-1); end
    end
    if isnan(dev(1)), dev(1)=0; end
    A = sum(0.5*(dev(1:end-1)+dev(2:end)).*dt);
    if ~isfinite(A), A = NaN; end
end

function oi = local_oscillation_index(dev)
    oi = NaN;
    if numel(dev)<3, oi=0; return; end
    d1 = diff(dev(:));
    s  = sign(d1); s(s==0)=1;
    oi = sum(abs(diff(s))>0) / max(numel(d1)-1,1);
end

function cnt = local_recovery_stalls(dev, thr, consecBeats)
    cnt=0;
    if isempty(dev), return; end
    under = dev(:) <= thr;
    if ~any(under), return; end
    enterIdx = find([false; (~under(1:end-1) & under(2:end))]);
    i=1; validSegments=0;
    while i<=numel(enterIdx)
        startPos = enterIdx(i)+1;
        len=0; j=startPos;
        while j<=numel(under) && under(j)
            len=len+1; j=j+1;
        end
        if len>=consecBeats, validSegments = validSegments+1; end
        i=i+1;
    end
    cnt = max(validSegments-1,0);
end

function qtc_seq = local_qtc_series(j_after, rGlobalAll, tGlobalIdx, qrs_dur_vec, rr_between, fs)
    qtc = nan(numel(j_after),1);
    for i=1:numel(j_after)
        j = j_after(i);
        if isfinite(tGlobalIdx(j)) && tGlobalIdx(j)>rGlobalAll(j) && isfinite(rr_between(j)) && rr_between(j)>0
            QT_approx = ((tGlobalIdx(j)-rGlobalAll(j))/fs) + 0.5*max(qrs_dur_vec(j),0);
            if isfinite(QT_approx) && QT_approx>=0.20 && QT_approx<=0.60
                qtc(i) = QT_approx / (rr_between(j)^(1/3));
            end
        end
    end
    qtc_seq = qtc(isfinite(qtc));
end

function rmssd_vec = local_rmssd_from_base_perPVC(idxPVC_all_sorted, pvcRidx, rGlobalAll, rr_between, isPVCBeat, sqi_vec, fs, params)
    numPVC = numel(idxPVC_all_sorted);
    rmssd_vec = nan(numPVC,1);
    for kk = 1:numPVC
        pvcSample = pvcRidx(kk);
        baseA = max(1, double(pvcSample)-round(params.baselineSec*fs));
        baseB = max(1, double(pvcSample)-1);
        j_in = find(rGlobalAll>=baseA & rGlobalAll<=baseB);
        j_in = j_in(:); j_in = j_in(j_in>=2);
        if isempty(j_in), continue; end
        mask_ok = ~isPVCBeat(j_in) & ~isPVCBeat(j_in-1) & sqi_vec(j_in) & sqi_vec(j_in-1) & isfinite(rr_between(j_in));
        rr_base = rr_between(j_in(mask_ok));
        rr_base = rr_base(isfinite(rr_base));
        if numel(rr_base)>=2
            d = diff(rr_base);
            rmssd_vec(kk) = sqrt(mean(d.^2));
        end
    end
end

% ---------------------------------------------------------------------------------
% Model / Prediction / Threshold
% ---------------------------------------------------------------------------------
function [trainedClassifier, validationAccuracy] = local_train_model(trainingTable, predictorNames, responseName, modelOptions)
    predictors = trainingTable(:, predictorNames);
    response = trainingTable.(responseName); if iscell(response), response = cell2mat(response); end

    % Compute subfeature sampling count
    numVars = modelOptions.NumVariablesToSample;
    if ischar(numVars) || isstring(numVars)
        if strcmpi(char(numVars),'all')
            numVarsArgGlobal = 'all';
        elseif strcmpi(char(numVars),'sqrt')
            p = width(predictors);
            numVarsArgGlobal = max(1, floor(sqrt(max(1,double(p)))));
        else
            numVarsArgGlobal = 'all';
        end
    else
        numVarsArgGlobal = max(1, round(double(numVars)));
    end

    % Non-auto mode
    if isfield(modelOptions,'Method') && ~strcmpi(char(modelOptions.Method),'auto')
        maxSplits = modelOptions.MaxNumSplits;
        if isfield(modelOptions,'MinLeafSize') && ~isempty(modelOptions.MinLeafSize)
            template = templateTree('MaxNumSplits',maxSplits,'NumVariablesToSample',numVarsArgGlobal,'MinLeafSize',modelOptions.MinLeafSize);
        else
            template = templateTree('MaxNumSplits',maxSplits,'NumVariablesToSample',numVarsArgGlobal);
        end
        fitArgs = {predictors, response,'Method',modelOptions.Method,'NumLearningCycles',modelOptions.NumLearningCycles,'Learners',template};
        if ~strcmpi(char(modelOptions.Method),'bag') && isfield(modelOptions,'LearnRate')
            fitArgs = [fitArgs, {'LearnRate', modelOptions.LearnRate}];
        end
        if isfield(modelOptions,'enableCostMatrix') && modelOptions.enableCostMatrix
            C = [0, modelOptions.costFP; modelOptions.costFN, 0];
            fitArgs = [fitArgs, {'Cost',C}];
        end
        cls = fitcensemble(fitArgs{:});
        try
            cv = crossval(cls,'KFold',modelOptions.cvKFold);
            validationAccuracy = 1 - kfoldLoss(cv);
        catch
            validationAccuracy = NaN;
        end
        trainedClassifier = struct();
        trainedClassifier.ClassificationEnsemble = cls;
        trainedClassifier.RequiredVariables = predictorNames;
        trainedClassifier.Options = modelOptions;
        return;
    end

    % Auto search
    if ~isfield(modelOptions,'candidateMethods') || isempty(modelOptions.candidateMethods)
        modelOptions.candidateMethods = {'LogitBoost','GentleBoost','AdaBoostM1','RUSBoost'};
    end
    if ~isfield(modelOptions,'searchGrid') || isempty(modelOptions.searchGrid)
        modelOptions.searchGrid = struct();
    end
    sg = modelOptions.searchGrid;
    if ~isfield(sg,'NumLearningCycles'),    sg.NumLearningCycles    = [200,300]; end
    if ~isfield(sg,'LearnRate'),            sg.LearnRate            = [0.03,0.05,0.10]; end
    if ~isfield(sg,'MaxNumSplits'),         sg.MaxNumSplits         = [40,60,100]; end
    if ~isfield(sg,'MinLeafSize'),          sg.MinLeafSize          = [8,12,20]; end
    if ~isfield(sg,'NumVariablesToSample'), sg.NumVariablesToSample = {'sqrt','all'}; end

    bestAUPRC = -inf; bestInfo = struct(); bestCls = []; bestValAcc = NaN;
    verbose = isfield(modelOptions,'autoSelectVerbose') && modelOptions.autoSelectVerbose;

    numMethods = numel(modelOptions.candidateMethods);
    combPerMethod = numel(sg.NumLearningCycles)*numel(sg.LearnRate)*numel(sg.MaxNumSplits)* ...
                    numel(sg.MinLeafSize)*numel(sg.NumVariablesToSample);
    totalComb = numMethods * combPerMethod;
    tried = 0;

    for mi = 1:numMethods
        methodName = char(modelOptions.candidateMethods{mi});
        for nlc = sg.NumLearningCycles
            for mns = sg.MaxNumSplits
                for mls = sg.MinLeafSize
                    for nvs = 1:numel(sg.NumVariablesToSample)
                        nvsVal = sg.NumVariablesToSample{nvs};
                        if ischar(nvsVal)||isstring(nvsVal)
                            if strcmpi(char(nvsVal),'all')
                                numVarsArg = 'all';
                            elseif strcmpi(char(nvsVal),'sqrt')
                                p = width(predictors);
                                numVarsArg = max(1,floor(sqrt(max(1,double(p)))));
                            else
                                numVarsArg = 'all';
                            end
                        else
                            numVarsArg = max(1, round(double(nvsVal)));
                        end
                        if ~isempty(mls)
                            template = templateTree('MaxNumSplits',mns,'NumVariablesToSample',numVarsArg,'MinLeafSize',mls);
                        else
                            template = templateTree('MaxNumSplits',mns,'NumVariablesToSample',numVarsArg);
                        end
                        for lr = sg.LearnRate
                            fitArgs = {predictors,response,'Method',methodName,'NumLearningCycles',nlc,'Learners',template,'LearnRate',lr};
                            if isfield(modelOptions,'enableCostMatrix') && modelOptions.enableCostMatrix
                                C = [0, modelOptions.costFP; modelOptions.costFN, 0];
                                fitArgs = [fitArgs, {'Cost',C}];
                            end
                            tried = tried + 1;
                            if verbose
                                fprintf('  [Auto %d/%d] %s NLC=%d LR=%.3f MaxSplits=%d MinLeaf=%d NumVars=%s\n', ...
                                    tried, totalComb, methodName, nlc, lr, mns, mls, mat2str(numVarsArg));
                            end
                            try
                                cls = fitcensemble(fitArgs{:});
                            catch
                                continue;
                            end
                            % CV AUPRC (Dead)
                            try
                                cvMdl = crossval(cls,'KFold',modelOptions.cvKFold);
                                valAcc = 1 - kfoldLoss(cvMdl);
                                [~, cvScores] = kfoldPredict(cvMdl);
                                try
                                    clsNames = cvMdl.ClassNames;
                                catch
                                    clsNames = [0;1];
                                end
                                if iscell(clsNames)
                                    try, clsNames = cell2mat(clsNames); catch, clsNames=[0;1]; end
                                end
                                col0 = find(clsNames==0,1,'first'); if isempty(col0), col0=1; end
                                scoresDead = cvScores(:,col0);
                                yDead = 1 - response;
                                try
                                    beta = glmfit(scoresDead, yDead, 'binomial','link','logit');
                                    scoresProb = glmval(beta, scoresDead, 'logit');
                                catch
                                    scoresProb = scoresDead;
                                end
                                try
                                    [~,~,~,auprcLocal] = perfcurve(yDead, scoresProb, 1, 'XCrit','reca','YCrit','prec');
                                catch
                                    [~,~,~,auprcLocal] = perfcurve(yDead, scoresDead, 1, 'XCrit','reca','YCrit','prec');
                                end
                                if isfinite(auprcLocal) && auprcLocal > bestAUPRC
                                    bestAUPRC = auprcLocal; bestCls = cls; bestValAcc = valAcc;
                                    bestInfo = struct('Method',methodName,'NumLearningCycles',nlc,'LearnRate',lr, ...
                                        'MaxNumSplits',mns,'MinLeafSize',mls,'NumVariablesToSample',nvsVal);
                                end
                            catch
                            end
                        end
                    end
                end
            end
        end
    end

    if verbose && ~isempty(fieldnames(bestInfo))
        fprintf('Auto-selected: %s NLC=%d LR=%.3f MaxSplits=%d MinLeaf=%d NumVars=%s | CV-AUPRC(Dead)=%.3f\n', ...
            string(bestInfo.Method), bestInfo.NumLearningCycles, bestInfo.LearnRate, ...
            bestInfo.MaxNumSplits, bestInfo.MinLeafSize, mat2str(bestInfo.NumVariablesToSample), bestAUPRC);
    end

    if isempty(bestCls)
        if verbose, fprintf('Auto-selection failed → fallback GentleBoost.\n'); end
        maxSplits = modelOptions.MaxNumSplits;
        if isfield(modelOptions,'MinLeafSize') && ~isempty(modelOptions.MinLeafSize)
            template = templateTree('MaxNumSplits',maxSplits,'NumVariablesToSample',numVarsArgGlobal,'MinLeafSize',modelOptions.MinLeafSize);
        else
            template = templateTree('MaxNumSplits',maxSplits,'NumVariablesToSample',numVarsArgGlobal);
        end
        fitArgs = {predictors,response,'Method','GentleBoost','NumLearningCycles',modelOptions.NumLearningCycles,'Learners',template,'LearnRate',modelOptions.LearnRate};
        if isfield(modelOptions,'enableCostMatrix') && modelOptions.enableCostMatrix
            C = [0, modelOptions.costFP; modelOptions.costFN, 0];
            fitArgs = [fitArgs, {'Cost',C}];
        end
        bestCls = fitcensemble(fitArgs{:});
        try
            cv = crossval(bestCls,'KFold',modelOptions.cvKFold);
            bestValAcc = 1 - kfoldLoss(cv);
        catch
            bestValAcc = NaN;
        end
        bestInfo = struct('Method','GentleBoost','NumLearningCycles',modelOptions.NumLearningCycles, ...
            'LearnRate',modelOptions.LearnRate,'MaxNumSplits',maxSplits,'MinLeafSize',modelOptions.MinLeafSize, ...
            'NumVariablesToSample',numVars);
    end

    trainedClassifier = struct();
    trainedClassifier.ClassificationEnsemble = bestCls;
    trainedClassifier.RequiredVariables = predictorNames;
    % Record selection info
    modelOptions.selectedMethod          = string(bestInfo.Method);
    modelOptions.Method                  = string(bestInfo.Method);
    modelOptions.NumLearningCycles       = double(bestInfo.NumLearningCycles);
    modelOptions.LearnRate               = double(bestInfo.LearnRate);
    modelOptions.MaxNumSplits            = double(bestInfo.MaxNumSplits);
    modelOptions.MinLeafSize             = double(bestInfo.MinLeafSize);
    modelOptions.NumVariablesToSample    = bestInfo.NumVariablesToSample;
    trainedClassifier.Options            = modelOptions;
    validationAccuracy = bestValAcc;
end

function model = local_threshold_tuning(model, Ttrain, predictorNames, responseName, modelOptions)
    rng(0);
    try
        cvMdl = crossval(model.ClassificationEnsemble,'KFold',modelOptions.cvKFold);
        [~, cvScores] = kfoldPredict(cvMdl);
        try
            cls = cvMdl.ClassNames;
        catch
            cls = [0;1];
        end
        if iscell(cls)
            try, cls = cell2mat(cls); catch, cls=[0;1]; end
        end
        col0 = find(cls==0,1,'first'); if isempty(col0), col0=1; end
        scoresDead = cvScores(:,col0);
    catch
        [~, scoresDead] = local_predict_with_threshold(model, Ttrain, predictorNames);
    end
    yTrain = Ttrain.(responseName); if iscell(yTrain), yTrain = cell2mat(yTrain); end
    yDead = 1 - yTrain;
    calibBeta = [];
    try
        calibBeta = glmfit(scoresDead, yDead, 'binomial','link','logit');
        scoresProb = glmval(calibBeta, scoresDead, 'logit');
    catch
        scoresProb = scoresDead;
        calibBeta = [];
    end

    bestThr = 0.5; bestF1 = -inf;
    for thr = modelOptions.thrCandidates
        yHatDead = double(scoresProb >= thr);
        TP = sum((yHatDead==1)&(yDead==1));
        FP = sum((yHatDead==1)&(yDead==0));
        FN = sum((yHatDead==0)&(yDead==1));
        prec = TP/max(TP+FP,eps); rec = TP/max(TP+FN,eps);
        F1 = (prec+rec>0) * (2*prec*rec/(prec+rec));
        if F1 > bestF1
            bestF1 = F1; bestThr = thr;
        end
    end
    model.Options.pvcThreshold = bestThr;
    if ~isempty(calibBeta)
        model.Options.calibrationBeta = calibBeta;
        fprintf('Platt calibration: beta=[%.4f %.4f]\n', calibBeta(1), calibBeta(2));
    end
    fprintf('Best threshold (CV F1[Dead]): %.2f (F1=%.3f)\n', bestThr, bestF1);
end

function [predVital, scoresDead] = local_predict_with_threshold(model, T, predictorNames)
    X = T(:, predictorNames);
    try
        [~, rawScores] = predict(model.ClassificationEnsemble, X);
    catch
        [~, rawScores] = predict(model.ClassificationEnsemble, X{:,:});
    end
    try
        cls = model.ClassificationEnsemble.ClassNames;
    catch
        cls = [0;1];
    end
    if iscell(cls)
        try, cls = cell2mat(cls); catch, cls=[0;1]; end
    end
    col0 = find(cls==0,1,'first'); if isempty(col0), col0=1; end
    scoresDead = rawScores(:,col0);
    scoresProb = scoresDead;
    if isfield(model,'Options') && isfield(model.Options,'calibrationBeta') && numel(model.Options.calibrationBeta)==2 && all(isfinite(model.Options.calibrationBeta))
        try
            scoresProb = glmval(model.Options.calibrationBeta, scoresDead, 'logit');
        catch
            scoresProb = scoresDead;
        end
    end
    thr = 0.5;
    if isfield(model,'Options') && isfield(model.Options,'enableThresholdMoving') && model.Options.enableThresholdMoving
        if isfield(model.Options,'pvcThreshold') && isfinite(model.Options.pvcThreshold)
            thr = model.Options.pvcThreshold;
        end
    end
    yHatDead = double(scoresProb >= thr);
    predVital = 1 - yHatDead;
end

function local_print_confusion(tag, yTrueVital, yHatVital)
    yTrueVital = double(yTrueVital(:));
    yHatVital  = double(yHatVital(:));
    yTrueDead  = 1 - yTrueVital;
    yHatDead   = 1 - yHatVital;
    TP = sum((yTrueDead==1)&(yHatDead==1));
    FN = sum((yTrueDead==1)&(yHatDead==0));
    FP = sum((yTrueDead==0)&(yHatDead==1));
    TN = sum((yTrueDead==0)&(yHatDead==0));
    acc = mean(yTrueVital==yHatVital);
    sens = TP/max(TP+FN,eps);          % Recall Dead
    spec = TN/max(TN+FP,eps);          % Specificity Alive
    prec = TP/max(TP+FP,eps);          % Precision Dead
    f1   = (prec+sens>0)*(2*prec*sens/(prec+sens));

    fprintf('\n--- %s Confusion Matrix (English) ---\n', tag);
    hdr = sprintf('%-14s%12s%12s','Actual\\Pred','Alive','Dead');
    fprintf('%s\n', hdr);
    fprintf('%s\n', repmat('-',1,length(hdr)));
    fprintf('%-14s%12d%12d\n','Alive',TN,FP);
    fprintf('%-14s%12d%12d\n','Dead', FN,TP);
    fprintf('Accuracy=%.2f%% | Recall(Dead)=%.2f%% | Specificity(Alive)=%.2f%% | Precision(Dead)=%.2f%% | F1(Dead)=%.3f\n', ...
        100*acc, 100*sens, 100*spec, 100*prec, f1);
    try
        figure;
        confMat = [TN FP; FN TP];
        confusionchart(confMat, {'Alive','Dead'}, 'RowSummary','row-normalized','ColumnSummary','column-normalized');
        title([tag ' Confusion']);
    catch
    end
end

function [trainMask, testMask] = local_group_stratified_split(groupIds, y, testRatio, seed)
    rng(seed);
    groupIds = string(groupIds(:));
    y = double(y(:));
    ug = unique(groupIds);
    G = struct('id',[], 'n0',0, 'n1',0, 'idx',[]);
    G = repmat(G, numel(ug),1);
    for i=1:numel(ug)
        gid = ug(i);
        idx = find(groupIds==gid);
        yi  = y(idx);
        G(i).id = gid; G(i).n0 = sum(yi==0); G(i).n1=sum(yi==1); G(i).idx=idx;
    end
    target0 = sum(y==0)*testRatio;
    target1 = sum(y==1)*testRatio;
    cur0=0; cur1=0; ord = randperm(numel(G));
    testGroups = false(numel(G),1);
    for k = ord
        g = G(k);
        gain0 = abs((cur0+g.n0)-target0) - abs(cur0-target0);
        gain1 = abs((cur1+g.n1)-target1) - abs(cur1-target1);
        if (cur0<target0 || cur1<target1) && ((gain0<=0)||(gain1<=0))
            testGroups(k)=true; cur0=cur0+g.n0; cur1=cur1+g.n1;
        end
    end
    k=1;
    while (cur0<target0 || cur1<target1) && k<=numel(G)
        if ~testGroups(k)
            g=G(k); testGroups(k)=true; cur0=cur0+g.n0; cur1=cur1+g.n1;
        end
        k=k+1;
    end
    testMask = false(numel(y),1);
    for i=1:numel(G)
        if testGroups(i)
            testMask(G(i).idx)=true;
        end
    end
    trainMask = ~testMask;
    % Ensure both classes appear in each split
    if sum(y(testMask)==1)==0
        idxMove = find(trainMask&(y==1),1,'first'); if ~isempty(idxMove), testMask(idxMove)=true; trainMask(idxMove)=false; end
    end
    if sum(y(testMask)==0)==0
        idxMove = find(trainMask&(y==0),1,'first'); if ~isempty(idxMove), testMask(idxMove)=true; trainMask(idxMove)=false; end
    end
    if sum(y(trainMask)==1)==0
        idxMove = find(testMask&(y==1),1,'first'); if ~isempty(idxMove), trainMask(idxMove)=true; testMask(idxMove)=false; end
    end
    if sum(y(trainMask)==0)==0
        idxMove = find(testMask&(y==0),1,'first'); if ~isempty(idxMove), trainMask(idxMove)=true; testMask(idxMove)=false; end
    end
end

function slope = local_linear_slope(t,x)
    slope=NaN;
    t=t(:); x=x(:);
    ok=isfinite(t)&isfinite(x); t=t(ok); x=x(ok);
    if numel(t)<2, return; end
    p=polyfit(t,x,1); slope=p(1);
end

function [SD1, SD2] = local_poincare_sd(rr)
    SD1=NaN; SD2=NaN;
    rr=rr(:); rr=rr(isfinite(rr));
    if numel(rr)<3, return; end
    d=diff(rr);
    sd_rr=std(rr); sd_d=std(d);
    SD1 = sqrt(0.5)*sd_d;
    tmp = 2*sd_rr^2 - 0.5*sd_d^2;
    if tmp>0, SD2 = sqrt(tmp); end
end

function v = local_safe_max(x)
    x=x(:); x=x(isfinite(x));
    if isempty(x), v=NaN; else, v=max(x); end
end

function v = local_safe_min(x)
    x=x(:); x=x(isfinite(x));
    if isempty(x), v=NaN; else, v=min(x); end
end

function s = local_sampen(x,m,r)
    s=NaN;
    x=x(:); x=x(isfinite(x));
    n=numel(x);
    if n < m+2 || ~isfinite(r) || r<=0, return; end
    count_m=0; count_m1=0;
    for i=1:(n-m)
        Xi = x(i:(i+m-1));
        for j=(i+1):(n-m+1)
            Xj = x(j:(j+m-1));
            if max(abs(Xi-Xj))<=r
                count_m = count_m + 1;
                if j <= n - m
                    if abs(x(i+m)-x(j+m))<=r
                        count_m1 = count_m1 + 1;
                    end
                end
            end
        end
    end
    if count_m==0 || count_m1==0, return; end
    s = -log(count_m1 / count_m);
end

function c = local_lzc_binary(b)
    c=NaN;
    b=b(:); b=b(isfinite(b));
    if isempty(b), return; end
    b=double(b~=0);
    n=numel(b);
    if n<2, c=0; return; end
    s=char(b+'0').';
    i=1; c_raw=1; l=1; k=1; k_max=1; nlen=length(s);
    while true
        if i+k>nlen || l+k>nlen
            c_raw=c_raw+1; break;
        end
        if s(i+k)==s(l+k)
            k=k+1; if k>k_max, k_max=k; end
        else
            if k>k_max, k_max=k; end
            if k_max==1
                c_raw=c_raw+1; l=l+1; i=1; k=1; k_max=1;
            else
                i=i+1;
                if i==l
                    c_raw=c_raw+1; l=l+k_max; i=1; k=1; k_max=1;
                else
                    k=1;
                end
            end
        end
        if l>nlen, break; end
    end
    c = c_raw * (log2(n))/n;
end

function [featStats] = local_feature_effectiveness(T, predictorNames, responseName, tag)
    yVital = T.(responseName); if iscell(yVital), yVital = cell2mat(yVital); end
    yDead = 1 - double(yVital(:));
    rows = numel(predictorNames);
    Feature=strings(rows,1); AUC=nan(rows,1); CohensD=nan(rows,1);
    SpearmanR=nan(rows,1); p_ranksum=nan(rows,1); MI_bits=nan(rows,1);
    for i=1:rows
        name = predictorNames{i}; Feature(i)=string(name);
        x = double(T.(name)); x = x(:);
        ok = isfinite(x)&isfinite(yDead);
        x = x(ok); y = yDead(ok);
        if numel(unique(y))<2 || numel(x)<5, continue; end
        try
            [~,~,~,auc] = perfcurve(y,x,1);
            if ~isfinite(auc), auc=NaN; end
            if auc<0.5, auc = 1 - auc; end
            AUC(i)=auc;
        catch
            AUC(i)=NaN;
        end
        try
            xd = x(y==1); xa = x(y==0);
            md=mean(xd); ma=mean(xa);
            sd_d=std(xd); sd_a=std(xa);
            n_d=numel(xd); n_a=numel(xa);
            s_p = sqrt(((n_d-1)*sd_d^2 + (n_a-1)*sd_a^2)/max(n_d+n_a-2,1));
            if s_p>0, CohensD(i)=(md-ma)/s_p; end
        catch, CohensD(i)=NaN; end
        try
            SpearmanR(i)=corr(x,y,'type','Spearman','rows','pairwise');
        catch, SpearmanR(i)=NaN; end
        try
            xd=x(y==1); xa=x(y==0);
            if numel(xd)>=2 && numel(xa)>=2
                p_ranksum(i)=ranksum(xd,xa);
            end
        catch, p_ranksum(i)=NaN; end
        try
            bins = local_quantile_bins(x,10);
            MI_bits(i) = local_mutual_info_bits(bins,y);
        catch, MI_bits(i)=NaN; end
    end
    featStats = table(Feature,AUC,CohensD,SpearmanR,p_ranksum,MI_bits);
    try
        fprintf('  [%s] median AUC=%.3f | top AUC=%.3f (%s)\n', tag, median(AUC,'omitnan'), max(AUC), string(Feature(AUC==max(AUC))));
    catch
    end
end

function bins = local_quantile_bins(x, numBins)
    x=x(:); ok=isfinite(x); x=x(ok);
    if isempty(x), bins=nan(size(ok)); return; end
    edges = quantile(x, linspace(0,1,numBins+1));
    edges(1)=-inf; edges(end)=inf;
    bins_full = nan(numel(ok),1);
    bins_full(ok) = discretize(x, edges);
    bins = bins_full;
end

function mi = local_mutual_info_bits(xBins, yBin)
    mi=NaN;
    if numel(xBins)~=numel(yBin), return; end
    ok=isfinite(xBins)&isfinite(yBin);
    xBins=xBins(ok); yBin=yBin(ok);
    if isempty(xBins), mi=NaN; return; end
    K = max(xBins);
    if K<=1, mi=0; return; end
    N=numel(xBins);
    px = accumarray(xBins,1,[K,1],@sum,0)/N;
    py = [sum(yBin==0); sum(yBin==1)]/N;
    pxy=zeros(K,2);
    for k=1:K
        sel = (xBins==k);
        pxy(k,1) = sum(sel & (yBin==0))/N;
        pxy(k,2) = sum(sel & (yBin==1))/N;
    end
    mi_val=0;
    for k=1:K
        for j=1:2
            if pxy(k,j)>0 && px(k)>0 && py(j)>0
                mi_val = mi_val + pxy(k,j)*log2(pxy(k,j)/(px(k)*py(j)));
            end
        end
    end
    mi=mi_val;
end

function f1 = local_f1_dead_from_scores(yDead, scoresDead, thr)
    yHatDead = double(scoresDead >= thr);
    TP = sum((yHatDead==1)&(yDead==1));
    FP = sum((yHatDead==1)&(yDead==0));
    FN = sum((yHatDead==0)&(yDead==1));
    prec = TP/max(TP+FP,eps); rec = TP/max(TP+FN,eps);
    if (prec+rec)>0
        f1 = 2*prec*rec/(prec+rec);
    else
        f1 = 0;
    end
end

function permImpTbl = local_permutation_importance(model, Ttest, predictorNames, responseName, thr, nRepeat)
    rng(0);
    [~, scores] = predict(model.ClassificationEnsemble, Ttest(:,predictorNames));
    try
        cls = model.ClassificationEnsemble.ClassNames;
    catch
        cls = [0;1];
    end
    if iscell(cls)
        try, cls = cell2mat(cls); catch, cls=[0;1]; end
    end
    col0 = find(cls==0,1,'first'); if isempty(col0), col0=1; end
    scoresDead = scores(:,col0);
    yVital = Ttest.(responseName); if iscell(yVital), yVital = cell2mat(yVital); end
    yDead = 1 - yVital;
    baseF1 = local_f1_dead_from_scores(yDead, scoresDead, thr);
    nF = numel(predictorNames);
    Feature=strings(nF,1); DeltaF1_mean=nan(nF,1); DeltaF1_std=nan(nF,1);
    for i=1:nF
        fname = predictorNames{i}; Feature(i)=string(fname);
        deltas = nan(nRepeat,1);
        for r=1:nRepeat
            Tperm = Ttest;
            vals = Tperm.(fname);
            idx = randperm(height(Tperm));
            Tperm.(fname) = vals(idx);
            [~, scoresP] = predict(model.ClassificationEnsemble, Tperm(:,predictorNames));
            scoresDeadP = scoresP(:,col0);
            f1p = local_f1_dead_from_scores(yDead, scoresDeadP, thr);
            deltas(r) = baseF1 - f1p;
        end
        DeltaF1_mean(i)=mean(deltas,'omitnan');
        DeltaF1_std(i)=std(deltas,'omitnan');
    end
    permImpTbl = table(Feature,DeltaF1_mean,DeltaF1_std);
    try
        permImpTbl = sortrows(permImpTbl,'DeltaF1_mean','descend');
    catch
    end
end

function local_generate_publication_plots(model, Ttrain, Ttest, predictorNames, responseName, resultsDir)
    try
        [~, rawScoresTr] = predict(model.ClassificationEnsemble, Ttrain(:,predictorNames));
        try
            cls = model.ClassificationEnsemble.ClassNames;
        catch
            cls = [0;1];
        end
        if iscell(cls)
            try, cls=cell2mat(cls); catch, cls=[0;1]; end
        end
        col0 = find(cls==0,1,'first'); if isempty(col0), col0=1; end
        scoresDeadTr = rawScoresTr(:,col0);
        scoresProbTr = scoresDeadTr;
        if isfield(model,'Options') && isfield(model.Options,'calibrationBeta')
            try
                scoresProbTr = glmval(model.Options.calibrationBeta, scoresDeadTr, 'logit');
            catch
            end
        end
        yVitalTr = Ttrain.(responseName); if iscell(yVitalTr), yVitalTr = cell2mat(yVitalTr); end
        yDeadTr = 1 - double(yVitalTr(:));

        [~, rawScoresTe] = predict(model.ClassificationEnsemble, Ttest(:,predictorNames));
        scoresDeadTe = rawScoresTe(:,col0);
        scoresProbTe = scoresDeadTe;
        if isfield(model,'Options') && isfield(model.Options,'calibrationBeta')
            try
                scoresProbTe = glmval(model.Options.calibrationBeta, scoresDeadTe, 'logit');
            catch
            end
        end
        yVitalTe = Ttest.(responseName); if iscell(yVitalTe), yVitalTe = cell2mat(yVitalTe); end
        yDeadTe = 1 - double(yVitalTe(:));

        % ROC
        try
            [Xtr,Ytr,~,aucTr] = perfcurve(yDeadTr, scoresProbTr,1);
        catch
            [Xtr,Ytr,~,aucTr] = perfcurve(yDeadTr, scoresDeadTr,1);
        end
        try
            [Xte,Yte,~,aucTe] = perfcurve(yDeadTe, scoresProbTe,1);
        catch
            [Xte,Yte,~,aucTe] = perfcurve(yDeadTe, scoresDeadTe,1);
        end
        figure; plot(Xte,Yte,'r-','LineWidth',2); hold on;
        plot(Xtr,Ytr,'b--','LineWidth',2); plot([0 1],[0 1],'k:','LineWidth',1.2);
        grid on; xlim([0,1]); ylim([0,1]);
        xlabel('False Positive Rate'); ylabel('True Positive Rate');
        title('ROC Curve (Dead=Positive)');
        legend({sprintf('Test (AUC=%.3f)',aucTe), sprintf('Train (AUC=%.3f)',aucTr), 'Chance'}, 'Location','southeast');
        try, exportgraphics(gcf, fullfile(resultsDir,'roc_curve_train_test.png'),'Resolution',300); catch, end

        % PR
        try
            [Rtr,Ptr,~,auprcTr] = perfcurve(yDeadTr, scoresProbTr,1,'XCrit','reca','YCrit','prec');
        catch
            [Rtr,Ptr,~,auprcTr] = perfcurve(yDeadTr, scoresDeadTr,1,'XCrit','reca','YCrit','prec');
        end
        try
            [Rte,Pte,~,auprcTe] = perfcurve(yDeadTe, scoresProbTe,1,'XCrit','reca','YCrit','prec');
        catch
            [Rte,Pte,~,auprcTe] = perfcurve(yDeadTe, scoresDeadTe,1,'XCrit','reca','YCrit','prec');
        end
        prevalTe = mean(yDeadTe);
        figure; plot(Rte,Pte,'r-','LineWidth',2); hold on;
        plot(Rtr,Ptr,'b--','LineWidth',2);
        yline(prevalTe,'k:','LineWidth',1.2,'Label','Prevalence (Test)','LabelHorizontalAlignment','left');
        grid on; xlim([0,1]); ylim([0,1]);
        xlabel('Recall'); ylabel('Precision');
        title('Precision-Recall (Dead=Positive)');
        legend({sprintf('Test (AUPRC=%.3f)',auprcTe), sprintf('Train (AUPRC=%.3f)',auprcTr), 'Baseline'}, 'Location','southwest');
        try, exportgraphics(gcf, fullfile(resultsDir,'pr_curve_train_test.png'),'Resolution',300); catch, end

        % Calibration
        numBins=10; edges=linspace(0,1,numBins+1);
        [~,~,binIdxTe] = histcounts(scoresProbTe, edges);
        binProb = accumarray(max(binIdxTe,1), scoresProbTe, [numBins,1], @mean, NaN);
        binObs  = accumarray(max(binIdxTe,1), yDeadTe,      [numBins,1], @mean, NaN);
        [~,~,binIdxTr] = histcounts(scoresProbTr, edges);
        binProbTr = accumarray(max(binIdxTr,1), scoresProbTr, [numBins,1], @mean, NaN);
        binObsTr  = accumarray(max(binIdxTr,1), yDeadTr,      [numBins,1], @mean, NaN);
        figure; plot([0 1],[0 1],'k:','LineWidth',1.2); hold on;
        plot(binProb,binObs,'ro-','LineWidth',2,'MarkerSize',6);
        plot(binProbTr,binObsTr,'bs--','LineWidth',2,'MarkerSize',6);
        grid on; xlim([0,1]); ylim([0,1]);
        xlabel('Predicted Probability (Dead)'); ylabel('Observed Rate (Dead)');
        title('Calibration'); legend('Perfect','Test','Train','Location','southeast');
        try, exportgraphics(gcf, fullfile(resultsDir,'calibration_curve_train_test.png'),'Resolution',300); catch, end

        % Decision Curve
        thrList=0.01:0.01:0.99; N=numel(yDeadTe);
        nbModel=nan(size(thrList)); nbAll=nan(size(thrList)); nbNone=zeros(size(thrList));
        preval = mean(yDeadTe);
        for ii=1:numel(thrList)
            pt=thrList(ii);
            yHat = scoresProbTe >= pt;
            TP = sum((yHat==1)&(yDeadTe==1));
            FP = sum((yHat==1)&(yDeadTe==0));
            nbModel(ii) = (TP/N) - (FP/N)*(pt/(1-pt));
            nbAll(ii)   = preval - (1 - preval)*(pt/(1-pt));
        end
        figure; plot(thrList,nbModel,'r-','LineWidth',2); hold on;
        plot(thrList,nbAll,'k--','LineWidth',1.8);
        plot(thrList,nbNone,'k:','LineWidth',1.8);
        grid on; xlim([0,1]);
        xlabel('Threshold Probability (Dead)'); ylabel('Net Benefit');
        title('Decision Curve (Test)');
        legend('Model','Treat All','Treat None','Location','northwest');
        try, exportgraphics(gcf, fullfile(resultsDir,'decision_curve_test.png'),'Resolution',300); catch, end
        fprintf('Saved evaluation plots.\n');
    catch ME
        fprintf('Plot generation error: %s\n', ME.message);
    end
end
