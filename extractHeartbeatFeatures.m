function [featureTable, featureNames] = extractHeartbeatFeatures(beatInfo, fs)
% ========================================================================
% File: extractHeartbeatFeatures.m
% Overview: Extract time-domain/morphology/rhythm features from per-beat
%           structured info and normalize them to form a feature table for
%           beat classification (PVC vs Other).
% Responsibilities:
%   1) Receive beatInfo array generated by detectAndClassifyHeartbeats and fs.
%   2) Compute RR intervals before/after (RR_Prev / RR_Post) to capture ectopic
%      rhythm perturbations.
%   3) Extract R/Q/S amplitudes and QRS duration with multi-level fallback
%      estimates (qrsOn/Off→Q/S→R/S→Q/R).
%   4) Compute QRS area (trapezoidal integral of |abs|); degrade gracefully so
%      an estimate is still provided when some markers are missing.
%   5) Build featureTable and perform per-column Z-score normalization
%      (robust fallback: if std≈0 → min-max).
%   6) Output featureNames list; the last column is the BeatType label (char/string).
% Inputs:
%   beatInfo (struct array):
%       .beatType            : 'Other' / 'PVC'
%       .segment             : beat segment (vector)
%       .rIndex / .qIndex / .sIndex
%       .qrsOnIndex / .qrsOffIndex (optional)
%       .segmentStartIndex   : absolute start index of segment in the raw ECG
%   fs (double)              : sampling frequency in Hz
% Outputs:
%   featureTable (table)     : normalized numeric feature columns + BeatType label
%   featureNames (cellstr)   : feature name sequence (includes BeatType)
% Key implementation notes:
%   - RR computed from absolute R indices (segmentStartIndex + rIndex - 1).
%   - QRS_Duration multi-level fallback; default 0.08 s when missing to avoid NaN spread.
%   - QRS_Area prioritizes qrsOn/Off; falls back to Q–S or R-centered window (~±40 ms).
%   - Normalization skips BeatType; if std≈0 → use min-max; skip if insufficient data.
%   - Force BeatType to string array for downstream classifier training.
% Edge/robustness strategies:
%   - Empty beatInfo: return empty table (0×N) with proper columns and exit safely.
%   - Bounds/NaN checks: validate indices before accessing segment.
%   - Missing temporal indices may yield NaN for intervals/area; handled in normalization.
%   - Print stats: normalization progress and label distribution for data QA.
% Changelog:
%   2025-08-30: Unified comment style; keep original algorithm logic unchanged.
% ========================================================================
featureNames = {'RR_Prev', 'RR_Post', 'R_Amplitude', 'Q_Amplitude', 'S_Amplitude', ...
                'QRS_Duration', 'QRS_Area', 'BeatType'}; % last column is the label

numBeats = length(beatInfo);
if numBeats == 0
    fprintf('Warning: beatInfo is empty; cannot extract features.\n');
    % Return an empty table with the same columns as featureNames
    featureTable = array2table(zeros(0, length(featureNames)), 'VariableNames', featureNames);
    % Ensure BeatType column is categorical when possible
    if any(strcmp(featureNames, 'BeatType'))
        featureTable.BeatType = categorical(featureTable.BeatType);
    end
    return;
end

% Initialize feature matrix and label array
% Numeric features (excluding BeatType)
numericalFeatureNames = setdiff(featureNames, {'BeatType'});
features = NaN(numBeats, length(numericalFeatureNames));

% Labels handled separately
beatTypeLabels = cell(numBeats, 1);

% Compute all absolute R indices for RR intervals
allRIndicesInECG = zeros(numBeats, 1);
for k = 1:numBeats
    % beatInfo(k).rIndex is index within the segment
    % beatInfo(k).segmentStartIndex is start index in the original ECG
    allRIndicesInECG(k) = beatInfo(k).segmentStartIndex + beatInfo(k).rIndex - 1;
end

for i = 1:numBeats
    currentBeat = beatInfo(i);
    segment = currentBeat.segment;
    rIdx = currentBeat.rIndex;
    qIdx = currentBeat.qIndex;
    sIdx = currentBeat.sIndex;
    
    % 1) RR interval features (RR_Prev, RR_Post), in seconds
    if i > 1
        rr_prev = (allRIndicesInECG(i) - allRIndicesInECG(i-1)) / fs;
        features(i, strcmp(numericalFeatureNames, 'RR_Prev')) = rr_prev;
    else
        features(i, strcmp(numericalFeatureNames, 'RR_Prev')) = NaN; % first beat has no previous RR
    end
    
    if i < numBeats
        rr_post = (allRIndicesInECG(i+1) - allRIndicesInECG(i)) / fs;
        features(i, strcmp(numericalFeatureNames, 'RR_Post')) = rr_post;
    else
        features(i, strcmp(numericalFeatureNames, 'RR_Post')) = NaN; % last beat has no next RR
    end
    
    % 2) Amplitude features (R, Q, S, T) - P_Amplitude removed
    % Units: mV (assuming original ECG in mV)
    if ~isnan(rIdx) && rIdx > 0 && rIdx <= length(segment)
        features(i, strcmp(numericalFeatureNames, 'R_Amplitude')) = segment(rIdx);
    end
    if ~isnan(qIdx) && qIdx > 0 && qIdx <= length(segment)
        features(i, strcmp(numericalFeatureNames, 'Q_Amplitude')) = segment(qIdx);
    end
    if ~isnan(sIdx) && sIdx > 0 && sIdx <= length(segment)
        features(i, strcmp(numericalFeatureNames, 'S_Amplitude')) = segment(sIdx);
    end
    
    % 3) Interval features
    % QRS duration: prioritize qrsOnIndex/qrsOffIndex (in-segment), otherwise fall back to Q/S/R logic
    qrsOnIdx = NaN; qrsOffIdx = NaN;
    if isfield(currentBeat,'qrsOnIndex'); qrsOnIdx = currentBeat.qrsOnIndex; end
    if isfield(currentBeat,'qrsOffIndex'); qrsOffIdx = currentBeat.qrsOffIndex; end
    if ~isnan(qrsOnIdx) && ~isnan(qrsOffIdx) && qrsOffIdx > qrsOnIdx
        features(i, strcmp(numericalFeatureNames, 'QRS_Duration')) = (qrsOffIdx - qrsOnIdx) / fs;
    elseif ~isnan(qIdx) && ~isnan(sIdx) && sIdx > qIdx
        features(i, strcmp(numericalFeatureNames, 'QRS_Duration')) = (sIdx - qIdx) / fs;
    elseif ~isnan(rIdx) && ~isnan(sIdx) && sIdx > rIdx
        features(i, strcmp(numericalFeatureNames, 'QRS_Duration')) = (sIdx - rIdx) / fs;
    elseif ~isnan(qIdx) && ~isnan(rIdx) && rIdx > qIdx
        features(i, strcmp(numericalFeatureNames, 'QRS_Duration')) = (rIdx - qIdx) / fs;
    else
        features(i, strcmp(numericalFeatureNames, 'QRS_Duration')) = 0.08;
    end
    
    % 4) Area feature (revised computation)
    % QRS area (trapezoidal integration), prioritize qrsOn/qrsOff
    if ~isnan(qrsOnIdx) && ~isnan(qrsOffIdx) && qrsOffIdx > qrsOnIdx && qrsOffIdx <= length(segment)
        qrs_segment = segment(qrsOnIdx:qrsOffIdx);
        features(i, strcmp(numericalFeatureNames, 'QRS_Area')) = trapz(abs(qrs_segment)) / fs;
    elseif ~isnan(qIdx) && ~isnan(sIdx) && sIdx > qIdx && sIdx <= length(segment)
        qrs_segment = segment(qIdx:sIdx);
        features(i, strcmp(numericalFeatureNames, 'QRS_Area')) = trapz(abs(qrs_segment)) / fs;
    elseif ~isnan(rIdx)
        r_area_start = max(1, rIdx - round(0.04*fs));
        r_area_end = min(length(segment), rIdx + round(0.04*fs));
        if r_area_end > r_area_start
            qrs_segment = segment(r_area_start:r_area_end);
            features(i, strcmp(numericalFeatureNames, 'QRS_Area')) = trapz(abs(qrs_segment)) / fs;
        end
    end
    
    % Note: no T-related area is used here
    
    % 5) Beat type label (handled separately)
    if isa(currentBeat.beatType, 'char') || isa(currentBeat.beatType, 'string')
        beatTypeLabels{i} = char(currentBeat.beatType); % ensure char type
    else
        beatTypeLabels{i} = 'Other'; % default
    end
end

% Create table for numeric features first
numericalFeatureTable = array2table(features, 'VariableNames', numericalFeatureNames);

% Add BeatType column
numericalFeatureTable.BeatType = beatTypeLabels;

% Reorder columns to ensure BeatType is last
featureTable = numericalFeatureTable(:, featureNames);

% Feature normalization (excluding BeatType column)
fprintf('Starting feature normalization...\n');
featureColumns = setdiff(featureNames, {'BeatType'}); % 排除BeatType列

for i = 1:length(featureColumns)
    colName = featureColumns{i};
    colData = featureTable{:, colName};
    
    % Remove NaNs for statistics
    validData = colData(~isnan(colData));
    
    if ~isempty(validData) && length(validData) > 1
        % Compute mean and std
        meanVal = mean(validData);
        stdVal = std(validData);
        
        % Z-score normalization (if std not ~0)
        if stdVal > 1e-10 % avoid divide-by-zero
            normalizedData = (colData - meanVal) / stdVal;
            featureTable{:, colName} = normalizedData;
            % fprintf('Feature %s: mean=%.4f, std=%.4f, normalized\n', colName, meanVal, stdVal);
        else
            % If std ~ 0, perform min-max normalization
            minVal = min(validData);
            maxVal = max(validData);
            if maxVal > minVal
                normalizedData = (colData - minVal) / (maxVal - minVal);
                featureTable{:, colName} = normalizedData;
                % fprintf('Feature %s: std≈0, used min-max normalization [%.4f, %.4f]\n', colName, minVal, maxVal);
            else
                fprintf('Feature %s: all values identical; skipping normalization\n', colName);
            end
        end
    else
        fprintf('Feature %s: insufficient valid data; skipping normalization\n', colName);
    end
end

% Ensure BeatType column is string type
if any(strcmp(featureNames, 'BeatType')) && ~isempty(featureTable)
    % BeatType column is a cell array; convert to string array
    if iscell(featureTable.BeatType)
        featureTable.BeatType = string(featureTable.BeatType);
    end
    fprintf('BeatType column ensured as string type\n');
end

% Print feature extraction statistics
fprintf('Feature extraction complete: %d beats, %d features (normalized).\n', numBeats, length(featureNames)-1);

% Show count per beat type
if ~isempty(featureTable)
    beatTypes = featureTable.BeatType;
    uniqueTypes = unique(beatTypes);
    fprintf('Beat type distribution:\n');
    for i = 1:length(uniqueTypes)
        count = sum(strcmp(beatTypes, uniqueTypes{i}));
        fprintf('  %s: %d beats (%.1f%%)\n', uniqueTypes{i}, count, (count/numBeats)*100);
    end
end

end
